{"meta":{"title":"HuoGuangjin","subtitle":"不安分的Android Dev","description":null,"author":"HuoGuangjin","url":"https://huoguangjin.github.io/blog"},"pages":[{"title":"","date":"2017-04-14T07:19:50.000Z","updated":"2017-04-14T07:19:49.000Z","comments":false,"path":"categories/index.html","permalink":"https://huoguangjin.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-14T11:04:58.000Z","updated":"2017-04-14T11:04:58.000Z","comments":false,"path":"tags/index.html","permalink":"https://huoguangjin.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty - Promise","slug":"Netty-Promise","date":"2017-04-29T05:52:19.000Z","updated":"2017-04-30T11:33:01.000Z","comments":true,"path":"2017/04/Netty-Promise/","link":"","permalink":"https://huoguangjin.github.io/blog/2017/04/Netty-Promise/","excerpt":"","text":"同步 / 异步Promise翻译过来大概是承诺的意思，在Netty中有什么用呢？ 为了更高效的IO（压榨多核CPU的运算能力），Netty将IO事件（由nio触发）分发到指定的线程转换为异步的操作，而Promise，就是用于线程间通信的。通过Promise，可以在多线程中做到同步变异步，异步变同步。 首先我们来明确这2个概念： 这里的同步/异步针对的是线程模型，而不是IO模型。 同步和异步是从消息通知的角度来区分的，以函数调用为例子。同步：调用一个函数后等待，直到得到返回结果才完成调用。异步：调用一个函数后不等待，完成调用，真正的结果通过其他方式获取（比如回调函数）。 比如去饭堂点煎饼果子，点完要排队等，直到做好了才能取。而点外卖只需要下个单就好了，外卖小哥会来电话叫你取的。同样是取食物，前者是同步的，后者是异步的。 DefaultPromise与Promise相关的类有很多，最关键的类就是DefaultPromise和DefaultChannelPromise，其他的xxxPromise都是继承自他们的，例如带进度通知功能的DefaultProgressivePromise、带聚合效果的SimpleChannelPromiseAggregator.. Promise UML 类图当中出现了两个Future接口，第一个是JDK并发包里的Future，第二个是io.netty.util.concurrent.Future，都是泛型类。 Netty的Future主要是扩展了监听器（Listener）的功能，这是异步回调的基础，另外一点就是扩展了结果的状态。原来的Future只有completed (或者叫done) 和cancelled两个结果，但completed只是笼统地概括了success和failure两个可能的情况，而Netty的Future细分了这两者。 12345678910111213141516 +---------------------------+ | Completed successfully | +---------------------------+ +----&gt; isDone() = true |+--------------------------+ | | isSuccess() = true || Uncompleted | | +===========================++--------------------------+ | | Completed with failure || isDone() = false | | +---------------------------+| isSuccess() = false |----+----&gt; isDone() = true || isCancelled() = false | | | cause() = non-null || cause() = null | | +===========================++--------------------------+ | | Completed by cancellation | | +---------------------------+ +----&gt; isDone() = true | | isCancelled() = true | +---------------------------+ Promise接口继承Future，主要是添加了setSuccess, trySuccess, setFailure, tryFailure, setUncancellable几个方法，用于更改Promise的状态。状态更改是不可逆的。 1234567891011121314151617181920212223public class DefaultPromise&lt;V&gt; extends AbstractFuture&lt;V&gt; implements Promise&lt;V&gt; &#123; private static final AtomicReferenceFieldUpdater&lt;DefaultPromise, Object&gt; RESULT_UPDATER; private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, \"SUCCESS\"); private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, \"UNCANCELLABLE\"); private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(new CancellationException()); static &#123; AtomicReferenceFieldUpdater&lt;DefaultPromise, Object&gt; updater = PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, \"result\"); RESULT_UPDATER = updater == null ? AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class, Object.class, \"result\") : updater; &#125; private volatile Object result; private final EventExecutor executor; private Object listeners; public DefaultPromise(EventExecutor executor) &#123; this.executor = checkNotNull(executor, \"executor\"); &#125; // ...&#125; DefaultPromise是Future和Promise接口的实现类，其中有几个重要的成员变量： executor：由构造函数传入，EventExecutor是Netty对线程的抽象，所有监听器的回调都发生在executor线程上。 listeners：监听器集合，这里用Object类型，不用List集合应该是为了省内存，实际类型是GenericFutureListener或DefaultFutureListeners。 result：Promise当前的状态，这里用Object类型，根据不同的状态实际类型可能是泛型V或SUCCESS, UNCANCELLABLE, CANCELLATION_CAUSE_HOLDER, CauseHolder，有volatile修饰，通过RESULT_UPDATER来更新。 RESULT_UPDATER：原子类 AtomicReferenceFieldUpdater 的实例，以CAS的方式更新实例的成员result。 DefaultChannelPromise比DefaultPromise主要多出了成员变量channel (Channel是Netty对Socket连接的抽象)，从构造函数中传入，如果没有指定线程executor，那么回调就会发生在channel所注册的线程上。 锁与监听器在Java当中，基类Object有wait/notify方法使得任何类都可以作为锁用于线程间通信，DefaultPromise充分利用这个特点，发挥了锁的作用。 sync, syncUninterruptibly, await, awaitUninterruptibly这几个方法用于同步，最后都会调用到基类Object的wait方法，当前线程会被挂起。 123456789101112131415161718192021222324@Overridepublic Promise&lt;V&gt; await() throws InterruptedException &#123; if (isDone()) &#123; return this; &#125; if (Thread.interrupted()) &#123; throw new InterruptedException(toString()); &#125; checkDeadLock(); // 检查死锁 synchronized (this) &#123; while (!isDone()) &#123; incWaiters(); try &#123; wait(); // 等待 &#125; finally &#123; decWaiters(); &#125; &#125; &#125; return this;&#125; setSuccess, trySuccess, setFailure, tryFailure, cancel这几个方法用于改变result状态，实现上都是利用RESULT_UPDATE通过CAS操作更新result，成功后都会调用checkNotifyWaiters方法来唤醒锁，然后再调用notifyListeners方法通知所有的监听器。 123456789101112131415161718192021222324252627@Overridepublic Promise&lt;V&gt; setSuccess(V result) &#123; if (setSuccess0(result)) &#123; notifyListeners(); // 通知监听器 return this; &#125; throw new IllegalStateException(\"complete already: \" + this);&#125;private boolean setSuccess0(V result) &#123; return setValue0(result == null ? SUCCESS : result);&#125;private boolean setValue0(Object objResult) &#123; if (RESULT_UPDATER.compareAndSet(this, null, objResult) || RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) &#123; checkNotifyWaiters(); return true; &#125; return false;&#125;private synchronized void checkNotifyWaiters() &#123; if (waiters &gt; 0) &#123; notifyAll(); // 唤醒锁 &#125;&#125; DefaultPromise的运作机制概括起来就是：对象锁等待与唤醒实现同步，监听器注册与回调实现异步。 同步 &amp; 异步假如现在要调用fetchData()函数发起一个网络请求，这个操作是耗时的。 12345678private String fetchData() throws IOException &#123; try &#123; Thread.sleep(3000L); // dummy request.. return \"response body\"; // dummy response.. &#125; catch (InterruptedException e) &#123; return null; // bad response &#125;&#125; 单线程123456789101112public void singleThread() &#123; try &#123; String result = fetchData(); if (result != null) &#123; System.out.println(result); &#125; else &#123; System.out.println(\"bad response\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 单线程的做法直观又简单。（如果你不是很介意Java的受检异常..） 多线程由于网络请求都是耗时的，往往需要在另外一条线程上执行，我们将这个步骤写成一个函数fetchDataSchedule，在worker线程上发起请求，返回一个Promise。 123456789101112131415161718private Promise&lt;String&gt; fetchDataSchedule(EventExecutor worker) &#123; final DefaultPromise&lt;String&gt; promise = new DefaultPromise&lt;&gt;(worker); worker.execute(() -&gt; &#123; try &#123; String result = fetchData(); if (result != null) &#123; promise.setSuccess(result); &#125; else &#123; promise.setFailure(new Throwable(\"bad response\")); &#125; &#125; catch (IOException e) &#123; promise.setFailure(e); &#125; &#125;); return promise;&#125; 下面来看看利用多线程执行时的同步和异步的写法： 同步1234567891011121314151617private void sync() &#123; DefaultEventExecutor worker = new DefaultEventExecutor(); Promise&lt;String&gt; promise = fetchDataSchedule(worker); try &#123; String result = promise.sync().getNow(); if (result != null) &#123; System.out.println(result); &#125; else &#123; promise.cause().printStackTrace(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; worker.shutdownGracefully(); &#125;&#125; 调用promise.sync()使主线程被挂起，一直等到worker线程获得结果才被唤醒，这时候结果也已经准备好了，直接取就好。可以看到同步的写法和单线程的写法看起来区别不大，执行效率也是很低的。在sync调用后，主线程什么都干不了，一直在等待结果，虽然一共有2条线程，事实上也就做了跟1条线程差不多的工作量，CPU利用率极低。 异步1234567891011121314151617private void async() &#123; DefaultEventExecutor worker = new DefaultEventExecutor(); Promise&lt;String&gt; promise = fetchDataSchedule(worker); promise.addListener(future -&gt; &#123; String result = promise.getNow(); if (result != null) &#123; System.out.println(result); &#125; else &#123; promise.cause().printStackTrace(); &#125; worker.shutdownGracefully(); &#125;); System.out.println(\"do something else\"); // do something else&#125; 通过设置监听器接收消息通知，主线程不会等待，请求一旦返回，就会在回调中处理结果。（回调是在worker线程中执行的，因为DefaultPromise的构造函数传入的是work线程）发起请求后，由worker线程来执行请求，而主线程可以做别的事情，充分发挥了线程资源，提高了CPU的利用率。 异步是不是很棒棒呢？异步回调的写法有个缺点，如果相互依赖的异步操作很多，相应的回调也会变得多，嵌套起来的画面太美，回调地狱（Callback Hell）可读性差且不利于维护。 解决回调地狱的办法也有很多，像RxJava、Android的Agera、JavaScript的Promise等等一系列的工具库。。。这几个解决方式各不相同，但基本上都是用的同一个套路：用队列/栈保存回调，返回包装类，提供链式调用，最后表现出来的就是flatten后的回调。","categories":[],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://huoguangjin.github.io/blog/tags/Netty/"},{"name":"Promise","slug":"Promise","permalink":"https://huoguangjin.github.io/blog/tags/Promise/"},{"name":"同步/异步","slug":"同步-异步","permalink":"https://huoguangjin.github.io/blog/tags/同步-异步/"}]},{"title":"Netty - FastThreadLocal","slug":"Netty-FastThreadLocal","date":"2017-04-21T12:48:09.000Z","updated":"2017-04-22T06:51:08.000Z","comments":true,"path":"2017/04/Netty-FastThreadLocal/","link":"","permalink":"https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/","excerpt":"","text":"ThreadLocalThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例，常见用static修饰。通过ThreadLocal可以让实例做到在线程作用域内独立，不需要考虑线程安全问题，在多线程编程中有奇效，也算是优化手段的一种。其中一个很经典的应用就是Android中的Looper类。 下面是来自文档的一个示例，使用ThreadLocal来储存一个整型值来作为线程的id，由于有static修饰，所以可以在任意地方使用ThreadId.get()获取当前线程的id： 123456789101112131415public class ThreadId &#123; // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return nextId.getAndIncrement(); &#125; &#125;; // Returns the current thread's unique ID, assigning it if necessary public static int get() &#123; return threadId.get(); &#125;&#125; 高性能网络框架Netty对ThreadLocal的实现进行了一番魔改，我们先来了解一下JDK中的ThreadLocal实现。 JDK的ThreadLocal实现ThreadLocal的实现，其实就是在Thread类里开了个挂。。Thread类有一个成员变量threadLocals，类型是ThreadLocal.ThreadLocalMap，同一线程的所有线程独立实例就是集中储存在这个”Map”当中。 12345678910111213public class Thread &#123; ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; // ...&#125; 不过虽然ThreadLocalMap名字中有”Map”，但是却没有实现Map接口，不过它实现方式和HashMap很相似，内部也有一个数组Entry[] tab，Entry类的声明很简单，就是一个储存key-value对的弱引用，key是ThreadLocal，而value就是我们要储存的线程独立实例，ThreadLocalMap看起来就像是一个Map&lt;ThreadLocal, Object&gt;。 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 以ThreadLocal的set方法入手分析，set方法分为2步： 获取从Thread中获取ThreadLocalMap 操作ThreadLocalMap设值 这里的ThreadLocalMap使用了懒加载的策略： 1234567891011121314151617181920public class ThreadLocal&lt;T&gt; &#123; private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; // ...&#125; 获取到ThreadLocalMap后调用它的set方法设值，set方法逻辑很简单：首先由key的哈希值（ThreadLocal初始化时由nextHashCode()赋值）算出数组下标，然后将value设置到对应的Entry上，如果你了解过HashMap的源码，那么应该对这套路很熟悉，只不过有一点不同，那就是解决哈希冲突的策略。 按照惯例，哈希表都是有可能发生冲突的，如果发生冲突会清除无效的Entry（弱引用 e != null &amp;&amp; e.get() == null），必要时还需要扩容和重哈希，具体实现在replaceStaleEntry()、cleanSomeSlots()、rehash()等方法中，这里不展开说了(有bu兴pa趣si的同学可以了解一下，注释里有提示Knuth, Section 6.4)，我们暂时只要知道这个冲突解决起来很累。。。 123456789101112131415161718192021222324252627282930313233343536static class ThreadLocalMap &#123; private Entry[] table; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果是在第一轮循环中则命中,否则就是发生了冲突 if (k == key) &#123; e.value = value; return; &#125; // 空的或失效(stale)的Entry if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 第一次设值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; // ...&#125; FastThreadLocalNetty为了高性能也是费尽了心思，专门造了个FastThreadLocal轮子来顶替ThreadLocal。 储存和JDK的Thread很类似，FastThreadLocaThread继承自Thread，用一个成员变量来储存线程独立的实例，FastThreadLocalThread.InternalThreadLocalMap的作用相当于ThreadLocal.ThreadLocalMap。 123456public class FastThreadLocalThread extends Thread &#123; private InternalThreadLocalMap threadLocalMap; // ...&#125; 和JDK相似，向FastThreadLocal设值需要两步： 获取从FastThreadLocalThread中获取InternalThreadLocalMap 操作InternalThreadLocalMap设值 12345678// io.netty.util.concurrent.FastThreadLocal.javapublic final void set(V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; set(InternalThreadLocalMap.get(), value); &#125; else &#123; remove(); &#125;&#125; InternalThreadLocalMap降级策略如果当前线程为FastThreadLocalThread则调用它的threadLocalMap()从中获取InternalThreadLocalMap，否则使用UnpaddedInternalThreadLocalMap的slowThreadLocalMap获取普通的ThreadLocal&lt;InternalThreadLocalMap&gt;，再从中获取InternalThreadLocalMap。同样地，InternalThreadLocalMap使用了懒加载。 123456789101112131415161718192021222324252627// InternalThreadLocalMap.javapublic static InternalThreadLocalMap get() &#123; Thread thread = Thread.currentThread(); if (thread instanceof FastThreadLocalThread) &#123; return fastGet((FastThreadLocalThread) thread); &#125; else &#123; return slowGet(); &#125;&#125;private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) &#123; InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); if (threadLocalMap == null) &#123; thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap()); &#125; return threadLocalMap;&#125;private static InternalThreadLocalMap slowGet() &#123; ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap; InternalThreadLocalMap ret = slowThreadLocalMap.get(); if (ret == null) &#123; ret = new InternalThreadLocalMap(); slowThreadLocalMap.set(ret); &#125; return ret;&#125; 获取FastThreadLocalInternalThreadLocalMap继承自UnpaddedInternalThreadLocalMap，真正储存的地方是在UnpaddedInternalThreadLocalMap的indexedVariables中，类型为Object[]。 12345678910111213class UnpaddedInternalThreadLocalMap &#123; static final AtomicInteger nextIndex = new AtomicInteger(); /** Used by &#123;@link FastThreadLocal&#125; */ Object[] indexedVariables; UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123; this.indexedVariables = indexedVariables; &#125; // ...&#125; 在FastThreadLocal的构造函数中，由InternalThreadLocalMap.nextVariableIndex()方法分配一个下标index，index的作用相当于一个id，后续读写都由这个index从InternalThreadLocalMap的indexVariables中查找线程独立对象。 InternalThreadLocalMap.nextVariableIndex()是通过调用UnpaddedInternalThreadLocalMap的nextIndex.getAndIncrement()方法获取的下标的，nextIndex是原子类AtomicInteger，保证生成的index是唯一的。 与JDK的实现相比，Netty的实现不会发生冲突，直接使用数组索引，效率更高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class InternalThreadLocalMap extends UnpaddedInternalThreadLocalMap &#123; public static final Object UNSET = new Object(); public static int nextVariableIndex() &#123; int index = nextIndex.getAndIncrement(); if (index &lt; 0) &#123; nextIndex.decrementAndGet(); throw new IllegalStateException(\"too many thread-local indexed variables\"); &#125; return index; &#125; public Object indexedVariable(int index) &#123; Object[] lookup = indexedVariables; return index &lt; lookup.length? lookup[index] : UNSET; &#125; public boolean setIndexedVariable(int index, Object value) &#123; Object[] lookup = indexedVariables; if (index &lt; lookup.length) &#123; Object oldValue = lookup[index]; lookup[index] = value; return oldValue == UNSET; &#125; else &#123; expandIndexedVariableTableAndSet(index, value); return true; &#125; &#125; // ...&#125;public class FastThreadLocal&lt;V&gt; &#123; private final int index; public FastThreadLocal() &#123; index = InternalThreadLocalMap.nextVariableIndex(); &#125; public final V get() &#123; return get(InternalThreadLocalMap.get()); &#125; public final void set(V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; set(InternalThreadLocalMap.get(), value); &#125; else &#123; remove(); &#125; &#125; public final void set(InternalThreadLocalMap threadLocalMap, V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; if (threadLocalMap.setIndexedVariable(index, value)) &#123; addToVariablesToRemove(threadLocalMap, this); &#125; &#125; else &#123; remove(threadLocalMap); &#125; &#125; // ...&#125; 从nextVariableIndex()方法可以看出nextIndex只递增不会减少，溢出（index &lt; 0）的话就会抛出IllegalStateException异常，毕竟是要用这个下标从数组中取对象的，不能小于0这很合理。 但是这里要注意：如果FastThreadLocal太多，index会越来越大，储存对象的indexedVariables数组为了满足需求会不断扩容，即使某些FastThreadLocal不会再使用。线程是不常回收的资源，线程FastThreadLocalThread持有的InternalThreadLocalMap也不会回收，这有可能会导致indexedVariables成为一个大数组，就算其中有大量空余的空间也无法再利用，也就是说这是个内存泄露点。反观JDK的实现，Entry是弱引用，经过清理操作后的空间可以被复用。 当然，如果数量需求不大，事实上不会有问题。在Netty中，FastThreadLocal的一个典型应用就是io.netty.util.Recycler类，它的作用就是个对象池，复用对象。对于多次使用的、创建开销大、线程无关的可复用对象都可以考虑使用ThreadLocal来优化。 事实上，Netty的FastThreadLocal分析到这里就结束了，不过因为内容相关，顺带加2个彩蛋： Android SDK的ThreadLocal实现Android(SDK23)中的ThreadLocal实现和JDK中的实现有些区别。ThreadLocal内部有弱引用reference，弱引用指向自身，哈希值取值也不一样，set方法倒是没什么区别。 12345678910111213141516171819public class ThreadLocal&lt;T&gt; &#123; private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this); private static AtomicInteger hashCounter = new AtomicInteger(0); private final int hash = hashCounter.getAndAdd(0x61c88647 * 2); public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value); &#125; // ...&#125; ThreadLocal.Values和JDK中的ThreadLocal.ThreadLocalMap的作用很相似，也是用数组作为元素的容器，但是没有Entry类来存key-value对，而是直接用了Object[] table来代替，其中偶数索引的元素上存key，紧挨着的下一个元素存vlaue。 每一次put都会先调用cleanUp()方法，cleanUp方法先判断需不需要扩容，如果扩容会自然地把失效的元素清除掉，如果不需要扩容，则按log2(table.length)的间距检查并标记失效的元素，之后再来做真正的插入操作。所谓的标记，就是把key位置上的元素用TOMBSTONE作占位，然后把value位置上的元素置为null，ThreadLocal调用remove方法删除实例的逻辑也是用的这种标记。 cleanUp()方法后，put方法剩余的部分很容易看懂，其中解决冲突的策略是：向后索引，插入到第一个空的或者TOMBSTONE的点上，从put方法可以看出Android中ThreadLocal解决冲突的策略相当的简单粗暴。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static class Values &#123; private static final Object TOMBSTONE = new Object(); private Object[] table; void put(ThreadLocal&lt;?&gt; key, Object value) &#123; cleanUp(); // Keep track of first tombstone. That's where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object k = table[index]; // 如果是在第一轮循环中,则命中,否则就是发生了冲突 if (k == key.reference) &#123; // Replace existing entry. table[index + 1] = value; return; &#125; // 空的或失效的ThreadLocal if (k == null) &#123; if (firstTombstone == -1) &#123; // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; &#125; // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; &#125; // Remember first tombstone. if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123; firstTombstone = index; &#125; &#125; &#125; private void cleanUp() &#123; if (rehash()) &#123; // If we rehashed, we needn't clean up (clean up happens as // a side effect). return; &#125; if (size == 0) &#123; // No live entries == nothing to clean. return; &#125; // Clean log(table.length) entries picking up where we left off // last time. int index = clean; Object[] table = this.table; for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1, index = next(index)) &#123; Object k = table[index]; if (k == TOMBSTONE || k == null) &#123; continue; // on to next entry &#125; // The table can only contain null, tombstones and references. @SuppressWarnings(\"unchecked\") Reference&lt;ThreadLocal&lt;?&gt;&gt; reference = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k; if (reference.get() == null) &#123; // This thread local was reclaimed by the garbage collector. table[index] = TOMBSTONE; table[index + 1] = null; tombstones++; size--; &#125; &#125; // Point cursor to next index. clean = index; &#125; // ... &#125; InheritableThreadLocalInheritableThreadLocal顾名思义就是有继承能力的ThreadLocal，子线程可以”继承”父线程内原有的InheritableThreadLocal变量。用起来很神奇，其实实现上也是Thread类里开了挂。。。 InheritableThreadLocal中的内容很少，只是复写了ThreadLocal的3个方法：childValue、getMap、createMap。 123456789public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125;&#125; ThreadLocal中原方法： 123456// ThreadLocalThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 对比两者可以看到，ThreadLocal的ThreadLocalMap是从thread的threadLocals变量中获取的，而InheritableThreadLocal的ThreadLocalMap则是从thread的inheritableThreadLocals变量获取的。 来看看Thread中开的挂：Thread的构造函数会调用init方法，然后将当前线程的inheritableThreadLocals复制了一份保存下来。 12345678910111213141516171819// Thread/* ThreadLocal values pertaining to this thread. This map is maintained* by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/** InheritableThreadLocal values pertaining to this thread. This map is* maintained by the InheritableThreadLocal class.*/ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;private void init(...) &#123; Thread parent = currentThread(); // ... if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); // ...&#125; ThreadLocal.createInheritedMap的实现如下，从中可以看到，所谓的”继承”，其实只是一次浅拷贝。 12345678910111213141516171819202122232425262728// ThreadLocalMapstatic ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap);&#125; private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings(\"unchecked\") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://huoguangjin.github.io/blog/tags/Netty/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://huoguangjin.github.io/blog/tags/ThreadLocal/"}]}]}