{"meta":{"title":"HuoGuangjin","subtitle":"不安分的Android Dev","description":null,"author":"HuoGuangjin","url":"https://huoguangjin.github.io/blog"},"pages":[{"title":"","date":"2017-04-14T11:04:58.000Z","updated":"2017-04-14T11:04:58.000Z","comments":false,"path":"tags/index.html","permalink":"https://huoguangjin.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-14T07:19:50.000Z","updated":"2017-04-14T07:19:49.000Z","comments":false,"path":"categories/index.html","permalink":"https://huoguangjin.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty - FastThreadLocal","slug":"Netty-FastThreadLocal","date":"2017-04-21T12:48:09.000Z","updated":"2017-04-22T06:51:08.000Z","comments":true,"path":"2017/04/Netty-FastThreadLocal/","link":"","permalink":"https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/","excerpt":"","text":"ThreadLocalThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例，常见用static修饰。通过ThreadLocal可以让实例做到在线程作用域内独立，不需要考虑线程安全问题，在多线程编程中有奇效，也算是优化手段的一种。其中一个很经典的应用就是Android中的Looper类。 下面是来自文档的一个示例，使用ThreadLocal来储存一个整型值来作为线程的id，由于有static修饰，所以可以在任意地方使用ThreadId.get()获取当前线程的id： 123456789101112131415public class ThreadId &#123; // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return nextId.getAndIncrement(); &#125; &#125;; // Returns the current thread's unique ID, assigning it if necessary public static int get() &#123; return threadId.get(); &#125;&#125; 高性能网络框架Netty对ThreadLocal的实现进行了一番魔改，我们先来了解一下JDK中的ThreadLocal实现。 JDK的ThreadLocal实现ThreadLocal的实现，其实就是在Thread类里开了个挂。。Thread类有一个成员变量threadLocals，类型是ThreadLocal.ThreadLocalMap，同一线程的所有线程独立实例就是集中储存在这个”Map”当中。 12345678910111213public class Thread &#123; ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; // ...&#125; 不过虽然ThreadLocalMap名字中有”Map”，但是却没有实现Map接口，不过它实现方式和HashMap很相似，内部也有一个数组Entry[] tab，Entry类的声明很简单，就是一个储存key-value对的弱引用，key是ThreadLocal，而value就是我们要储存的线程独立实例，ThreadLocalMap看起来就像是一个Map&lt;ThreadLocal, Object&gt;。 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 以ThreadLocal的set方法入手分析，set方法分为2步： 获取从Thread中获取ThreadLocalMap 操作ThreadLocalMap设值 这里的ThreadLocalMap使用了懒加载的策略： 1234567891011121314151617181920public class ThreadLocal&lt;T&gt; &#123; private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; // ...&#125; 获取到ThreadLocalMap后调用它的set方法设值，set方法逻辑很简单：首先由key的哈希值（ThreadLocal初始化时由nextHashCode()赋值）算出数组下标，然后将value设置到对应的Entry上，如果你了解过HashMap的源码，那么应该对这套路很熟悉，只不过有一点不同，那就是解决哈希冲突的策略。 按照惯例，哈希表都是有可能发生冲突的，如果发生冲突会清除无效的Entry（弱引用 e != null &amp;&amp; e.get() == null），必要时还需要扩容和重哈希，具体实现在replaceStaleEntry()、cleanSomeSlots()、rehash()等方法中，这里不展开说了(有bu兴pa趣si的同学可以了解一下，注释里有提示Knuth, Section 6.4)，我们暂时只要知道这个冲突解决起来很累。。。 123456789101112131415161718192021222324252627282930313233343536static class ThreadLocalMap &#123; private Entry[] table; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果是在第一轮循环中则命中,否则就是发生了冲突 if (k == key) &#123; e.value = value; return; &#125; // 空的或失效(stale)的Entry if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 第一次设值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; // ...&#125; FastThreadLocalNetty为了高性能也是费尽了心思，专门造了个FastThreadLocal轮子来顶替ThreadLocal。 储存和JDK的Thread很类似，FastThreadLocaThread继承自Thread，用一个成员变量来储存线程独立的实例，FastThreadLocalThread.InternalThreadLocalMap的作用相当于ThreadLocal.ThreadLocalMap。 123456public class FastThreadLocalThread extends Thread &#123; private InternalThreadLocalMap threadLocalMap; // ...&#125; 和JDK相似，向FastThreadLocal设值需要两步： 获取从FastThreadLocalThread中获取InternalThreadLocalMap 操作InternalThreadLocalMap设值 12345678// io.netty.util.concurrent.FastThreadLocal.javapublic final void set(V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; set(InternalThreadLocalMap.get(), value); &#125; else &#123; remove(); &#125;&#125; InternalThreadLocalMap降级策略如果当前线程为FastThreadLocalThread则调用它的threadLocalMap()从中获取InternalThreadLocalMap，否则使用UnpaddedInternalThreadLocalMap的slowThreadLocalMap获取普通的ThreadLocal&lt;InternalThreadLocalMap&gt;，再从中获取InternalThreadLocalMap。同样地，InternalThreadLocalMap使用了懒加载。 123456789101112131415161718192021222324252627// InternalThreadLocalMap.javapublic static InternalThreadLocalMap get() &#123; Thread thread = Thread.currentThread(); if (thread instanceof FastThreadLocalThread) &#123; return fastGet((FastThreadLocalThread) thread); &#125; else &#123; return slowGet(); &#125;&#125;private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) &#123; InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); if (threadLocalMap == null) &#123; thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap()); &#125; return threadLocalMap;&#125;private static InternalThreadLocalMap slowGet() &#123; ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap; InternalThreadLocalMap ret = slowThreadLocalMap.get(); if (ret == null) &#123; ret = new InternalThreadLocalMap(); slowThreadLocalMap.set(ret); &#125; return ret;&#125; 获取FastThreadLocalInternalThreadLocalMap继承自UnpaddedInternalThreadLocalMap，真正储存的地方是在UnpaddedInternalThreadLocalMap的indexedVariables中，类型为Object[]。 12345678910111213class UnpaddedInternalThreadLocalMap &#123; static final AtomicInteger nextIndex = new AtomicInteger(); /** Used by &#123;@link FastThreadLocal&#125; */ Object[] indexedVariables; UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123; this.indexedVariables = indexedVariables; &#125; // ...&#125; 在FastThreadLocal的构造函数中，由InternalThreadLocalMap.nextVariableIndex()方法分配一个下标index，index的作用相当于一个id，后续读写都由这个index从InternalThreadLocalMap的indexVariables中查找线程独立对象。 InternalThreadLocalMap.nextVariableIndex()是通过调用UnpaddedInternalThreadLocalMap的nextIndex.getAndIncrement()方法获取的下标的，nextIndex是原子类AtomicInteger，保证生成的index是唯一的。 与JDK的实现相比，Netty的实现不会发生冲突，直接使用数组索引，效率更高。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class InternalThreadLocalMap extends UnpaddedInternalThreadLocalMap &#123; public static final Object UNSET = new Object(); public static int nextVariableIndex() &#123; int index = nextIndex.getAndIncrement(); if (index &lt; 0) &#123; nextIndex.decrementAndGet(); throw new IllegalStateException(\"too many thread-local indexed variables\"); &#125; return index; &#125; public Object indexedVariable(int index) &#123; Object[] lookup = indexedVariables; return index &lt; lookup.length? lookup[index] : UNSET; &#125; public boolean setIndexedVariable(int index, Object value) &#123; Object[] lookup = indexedVariables; if (index &lt; lookup.length) &#123; Object oldValue = lookup[index]; lookup[index] = value; return oldValue == UNSET; &#125; else &#123; expandIndexedVariableTableAndSet(index, value); return true; &#125; &#125; // ...&#125;public class FastThreadLocal&lt;V&gt; &#123; private final int index; public FastThreadLocal() &#123; index = InternalThreadLocalMap.nextVariableIndex(); &#125; public final V get() &#123; return get(InternalThreadLocalMap.get()); &#125; public final void set(V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; set(InternalThreadLocalMap.get(), value); &#125; else &#123; remove(); &#125; &#125; public final void set(InternalThreadLocalMap threadLocalMap, V value) &#123; if (value != InternalThreadLocalMap.UNSET) &#123; if (threadLocalMap.setIndexedVariable(index, value)) &#123; addToVariablesToRemove(threadLocalMap, this); &#125; &#125; else &#123; remove(threadLocalMap); &#125; &#125; // ...&#125; 从nextVariableIndex()方法可以看出nextIndex只递增不会减少，溢出（index &lt; 0）的话就会抛出IllegalStateException异常，毕竟是要用这个下标从数组中取对象的，不能小于0这很合理。 但是这里要注意：如果FastThreadLocal太多，index会越来越大，储存对象的indexedVariables数组为了满足需求会不断扩容，即使某些FastThreadLocal不会再使用。线程是不常回收的资源，线程FastThreadLocalThread持有的InternalThreadLocalMap也不会回收，这有可能会导致indexedVariables成为一个大数组，就算其中有大量空余的空间也无法再利用，也就是说这是个内存泄露点。反观JDK的实现，Entry是弱引用，经过清理操作后的空间可以被复用。 当然，如果数量需求不大，事实上不会有问题。在Netty中，FastThreadLocal的一个典型应用就是io.netty.util.Recycler类，它的作用就是个对象池，复用对象。对于多次使用的、创建开销大、线程无关的可复用对象都可以考虑使用ThreadLocal来优化。 事实上，Netty的FastThreadLocal分析到这里就结束了，不过因为内容相关，顺带加2个彩蛋： Android SDK的ThreadLocal实现Android(SDK23)中的ThreadLocal实现和JDK中的实现有些区别。ThreadLocal内部有弱引用reference，弱引用指向自身，哈希值取值也不一样，set方法倒是没什么区别。 12345678910111213141516171819public class ThreadLocal&lt;T&gt; &#123; private final Reference&lt;ThreadLocal&lt;T&gt;&gt; reference = new WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(this); private static AtomicInteger hashCounter = new AtomicInteger(0); private final int hash = hashCounter.getAndAdd(0x61c88647 * 2); public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value); &#125; // ...&#125; ThreadLocal.Values和JDK中的ThreadLocal.ThreadLocalMap的作用很相似，也是用数组作为元素的容器，但是没有Entry类来存key-value对，而是直接用了Object[] table来代替，其中偶数索引的元素上存key，紧挨着的下一个元素存vlaue。 每一次put都会先调用cleanUp()方法，cleanUp方法先判断需不需要扩容，如果扩容会自然地把失效的元素清除掉，如果不需要扩容，则按log2(table.length)的间距检查并标记失效的元素，之后再来做真正的插入操作。所谓的标记，就是把key位置上的元素用TOMBSTONE作占位，然后把value位置上的元素置为null，ThreadLocal调用remove方法删除实例的逻辑也是用的这种标记。 cleanUp()方法后，put方法剩余的部分很容易看懂，其中解决冲突的策略是：向后索引，插入到第一个空的或者TOMBSTONE的点上，从put方法可以看出Android中ThreadLocal解决冲突的策略相当的简单粗暴。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static class Values &#123; private static final Object TOMBSTONE = new Object(); private Object[] table; void put(ThreadLocal&lt;?&gt; key, Object value) &#123; cleanUp(); // Keep track of first tombstone. That's where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object k = table[index]; // 如果是在第一轮循环中,则命中,否则就是发生了冲突 if (k == key.reference) &#123; // Replace existing entry. table[index + 1] = value; return; &#125; // 空的或失效的ThreadLocal if (k == null) &#123; if (firstTombstone == -1) &#123; // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; &#125; // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; &#125; // Remember first tombstone. if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123; firstTombstone = index; &#125; &#125; &#125; private void cleanUp() &#123; if (rehash()) &#123; // If we rehashed, we needn't clean up (clean up happens as // a side effect). return; &#125; if (size == 0) &#123; // No live entries == nothing to clean. return; &#125; // Clean log(table.length) entries picking up where we left off // last time. int index = clean; Object[] table = this.table; for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1, index = next(index)) &#123; Object k = table[index]; if (k == TOMBSTONE || k == null) &#123; continue; // on to next entry &#125; // The table can only contain null, tombstones and references. @SuppressWarnings(\"unchecked\") Reference&lt;ThreadLocal&lt;?&gt;&gt; reference = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k; if (reference.get() == null) &#123; // This thread local was reclaimed by the garbage collector. table[index] = TOMBSTONE; table[index + 1] = null; tombstones++; size--; &#125; &#125; // Point cursor to next index. clean = index; &#125; // ... &#125; InheritableThreadLocalInheritableThreadLocal顾名思义就是有继承能力的ThreadLocal，子线程可以”继承”父线程内原有的InheritableThreadLocal变量。用起来很神奇，其实实现上也是Thread类里开了挂。。。 InheritableThreadLocal中的内容很少，只是复写了ThreadLocal的3个方法：childValue、getMap、createMap。 123456789public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125;&#125; ThreadLocal中原方法： 123456// ThreadLocalThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 对比两者可以看到，ThreadLocal的ThreadLocalMap是从thread的threadLocals变量中获取的，而InheritableThreadLocal的ThreadLocalMap则是从thread的inheritableThreadLocals变量获取的。 来看看Thread中开的挂：Thread的构造函数会调用init方法，然后将当前线程的inheritableThreadLocals复制了一份保存下来。 12345678910111213141516171819// Thread/* ThreadLocal values pertaining to this thread. This map is maintained* by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/** InheritableThreadLocal values pertaining to this thread. This map is* maintained by the InheritableThreadLocal class.*/ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;private void init(...) &#123; Thread parent = currentThread(); // ... if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); // ...&#125; ThreadLocal.createInheritedMap的实现如下，从中可以看到，所谓的”继承”，其实只是一次浅拷贝。 12345678910111213141516171819202122232425262728// ThreadLocalMapstatic ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap);&#125; private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings(\"unchecked\") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://huoguangjin.github.io/blog/tags/Netty/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://huoguangjin.github.io/blog/tags/ThreadLocal/"}]}]}