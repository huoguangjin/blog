<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuoGuangjin</title>
  <subtitle>不安分的Android Dev</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://huoguangjin.github.io/blog/"/>
  <updated>2017-04-30T11:33:01.000Z</updated>
  <id>https://huoguangjin.github.io/blog/</id>
  
  <author>
    <name>HuoGuangjin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty - Promise</title>
    <link href="https://huoguangjin.github.io/blog/2017/04/Netty-Promise/"/>
    <id>https://huoguangjin.github.io/blog/2017/04/Netty-Promise/</id>
    <published>2017-04-29T05:52:19.000Z</published>
    <updated>2017-04-30T11:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 / 异步"></a>同步 / 异步</h1><p>Promise翻译过来大概是承诺的意思，在Netty中有什么用呢？</p>
<p>为了更高效的IO（压榨多核CPU的运算能力），Netty将IO事件（由nio触发）分发到指定的线程转换为异步的操作，而Promise，就是用于线程间通信的。通过Promise，可以在多线程中做到同步变异步，异步变同步。</p>
<p>首先我们来明确这2个概念：</p>
<blockquote>
<p>这里的同步/异步针对的是<strong>线程</strong>模型，而不是IO模型。</p>
</blockquote>
<p>同步和异步是从<strong>消息通知</strong>的角度来区分的，以函数调用为例子。<br>同步：调用一个函数后等待，直到得到返回结果才完成调用。<br>异步：调用一个函数后不等待，完成调用，真正的结果通过其他方式获取（比如回调函数）。</p>
<p>比如去饭堂点煎饼果子，点完要排队等，直到做好了才能取。<br>而点外卖只需要下个单就好了，外卖小哥会来电话叫你取的。<br>同样是取食物，前者是同步的，后者是异步的。</p>
<h1 id="DefaultPromise"><a href="#DefaultPromise" class="headerlink" title="DefaultPromise"></a>DefaultPromise</h1><p>与Promise相关的类有很多，最关键的类就是<code>DefaultPromise</code>和<code>DefaultChannelPromise</code>，其他的xxxPromise都是继承自他们的，例如带进度通知功能的DefaultProgressivePromise、带聚合效果的SimpleChannelPromiseAggregator..</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="promise_uml.png" alt="Promise UML" title="">
                </div>
                <div class="image-caption">Promise UML</div>
            </figure>
<p>类图当中出现了两个Future接口，第一个是JDK并发包里的Future，第二个是io.netty.util.concurrent.Future，都是泛型类。</p>
<p>Netty的Future主要是扩展了监听器（Listener）的功能，这是异步回调的基础，另外一点就是扩展了结果的状态。原来的Future只有<code>completed</code> (或者叫done) 和<code>cancelled</code>两个结果，但completed只是笼统地概括了<code>success</code>和<code>failure</code>两个可能的情况，而Netty的Future细分了这两者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">                                     +---------------------------+</div><div class="line">                                     | Completed successfully    |</div><div class="line">                                     +---------------------------+</div><div class="line">                                +----&gt;      isDone() = true      |</div><div class="line">+--------------------------+    |    |   isSuccess() = true      |</div><div class="line">|        Uncompleted       |    |    +===========================+</div><div class="line">+--------------------------+    |    | Completed with failure    |</div><div class="line">|      isDone() = false    |    |    +---------------------------+</div><div class="line">|   isSuccess() = false    |----+----&gt;      isDone() = true      |</div><div class="line">| isCancelled() = false    |    |    |       cause() = non-null  |</div><div class="line">|       cause() = null     |    |    +===========================+</div><div class="line">+--------------------------+    |    | Completed by cancellation |</div><div class="line">                                |    +---------------------------+</div><div class="line">                                +----&gt;      isDone() = true      |</div><div class="line">                                     | isCancelled() = true      |</div><div class="line">                                     +---------------------------+</div></pre></td></tr></table></figure>
<p>Promise接口继承Future，主要是添加了<code>setSuccess</code>, <code>trySuccess</code>, <code>setFailure</code>, <code>tryFailure</code>, <code>setUncancellable</code>几个方法，用于更改Promise的状态。状态更改是不可逆的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPromise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;DefaultPromise, Object&gt; RESULT_UPDATER;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Signal SUCCESS = Signal.valueOf(DefaultPromise.class, <span class="string">"SUCCESS"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, <span class="string">"UNCANCELLABLE"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CauseHolder CANCELLATION_CAUSE_HOLDER = <span class="keyword">new</span> CauseHolder(<span class="keyword">new</span> CancellationException());</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        AtomicReferenceFieldUpdater&lt;DefaultPromise, Object&gt; updater =</div><div class="line">                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, <span class="string">"result"</span>);</div><div class="line">        RESULT_UPDATER = updater == <span class="keyword">null</span> ?</div><div class="line">                AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class, Object.class, <span class="string">"result"</span>) : updater; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</div><div class="line">    <span class="keyword">private</span> Object listeners;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPromise</span><span class="params">(EventExecutor executor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.executor = checkNotNull(executor, <span class="string">"executor"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DefaultPromise是Future和Promise接口的实现类，其中有几个重要的成员变量：</p>
<ul>
<li><strong>executor</strong>：由构造函数传入，EventExecutor是Netty对线程的抽象，所有监听器的回调都发生在executor线程上。</li>
<li><strong>listeners</strong>：监听器集合，这里用Object类型，不用List集合应该是为了省内存，实际类型是<code>GenericFutureListener</code>或<code>DefaultFutureListeners</code>。</li>
<li><strong>result</strong>：Promise当前的状态，这里用Object类型，根据不同的状态实际类型可能是<code>泛型V</code>或<code>SUCCESS</code>, <code>UNCANCELLABLE</code>, <code>CANCELLATION_CAUSE_HOLDER</code>, <code>CauseHolder</code>，有volatile修饰，通过RESULT_UPDATER来更新。</li>
<li><strong>RESULT_UPDATER</strong>：原子类 AtomicReferenceFieldUpdater<defaultpromise, object=""> 的实例，以CAS的方式更新实例的成员result。</defaultpromise,></li>
</ul>
<p>DefaultChannelPromise比DefaultPromise主要多出了成员变量channel (Channel是Netty对Socket连接的抽象)，从构造函数中传入，如果没有指定线程executor，那么回调就会发生在channel所注册的线程上。</p>
<h2 id="锁与监听器"><a href="#锁与监听器" class="headerlink" title="锁与监听器"></a>锁与监听器</h2><p>在Java当中，基类Object有wait/notify方法使得任何类都可以作为锁用于线程间通信，DefaultPromise充分利用这个特点，发挥了锁的作用。</p>
<p><code>sync</code>, <code>syncUninterruptibly</code>, <code>await</code>, <code>awaitUninterruptibly</code>这几个方法用于同步，最后都会调用到基类Object的wait方法，当前线程会被挂起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isDone()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    checkDeadLock(); <span class="comment">// 检查死锁</span></div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (!isDone()) &#123;</div><div class="line">            incWaiters();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                wait(); <span class="comment">// 等待</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                decWaiters();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setSuccess</code>, <code>trySuccess</code>, <code>setFailure</code>, <code>tryFailure</code>, <code>cancel</code>这几个方法用于改变result状态，实现上都是利用RESULT_UPDATE通过CAS操作更新result，成功后都会调用<code>checkNotifyWaiters</code>方法来唤醒锁，然后再调用<code>notifyListeners</code>方法通知所有的监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</div><div class="line">        notifyListeners(); <span class="comment">// 通知监听器</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSuccess0</span><span class="params">(V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> setValue0(result == <span class="keyword">null</span> ? SUCCESS : result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</div><div class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</div><div class="line">        checkNotifyWaiters();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkNotifyWaiters</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (waiters &gt; <span class="number">0</span>) &#123;</div><div class="line">        notifyAll(); <span class="comment">// 唤醒锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DefaultPromise的运作机制概括起来就是：<strong>对象锁等待与唤醒实现同步，监听器注册与回调实现异步</strong>。</p>
<h1 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h1><p>假如现在要调用<code>fetchData()</code>函数发起一个网络请求，这个操作是耗时的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">fetchData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(<span class="number">3000L</span>); <span class="comment">// dummy request..</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"response body"</span>;  <span class="comment">// dummy response..</span></div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// bad response</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String result = fetchData();</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(result);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"bad response"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单线程的做法直观又简单。（如果你不是很介意Java的受检异常..）</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>由于网络请求都是耗时的，往往需要在另外一条线程上执行，我们将这个步骤写成一个函数<code>fetchDataSchedule</code>，在worker线程上发起请求，返回一个Promise。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Promise&lt;String&gt; <span class="title">fetchDataSchedule</span><span class="params">(EventExecutor worker)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> DefaultPromise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(worker);</div><div class="line">    </div><div class="line">    worker.execute(() -&gt; &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String result = fetchData();</div><div class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">                promise.setSuccess(result);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(<span class="keyword">new</span> Throwable(<span class="string">"bad response"</span>));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            promise.setFailure(e);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看看利用多线程执行时的<code>同步</code>和<code>异步</code>的写法：</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</div><div class="line">    DefaultEventExecutor worker = <span class="keyword">new</span> DefaultEventExecutor();</div><div class="line">    Promise&lt;String&gt; promise = fetchDataSchedule(worker);</div><div class="line">    </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String result = promise.sync().getNow();</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(result);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            promise.cause().printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        worker.shutdownGracefully();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用<code>promise.sync()</code>使主线程被挂起，一直等到worker线程获得结果才被唤醒，这时候结果也已经准备好了，直接取就好。<br>可以看到同步的写法和单线程的写法看起来区别不大，执行效率也是很低的。在<code>sync</code>调用后，主线程什么都干不了，一直在等待结果，虽然一共有2条线程，事实上也就做了跟1条线程差不多的工作量，CPU利用率极低。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">async</span><span class="params">()</span> </span>&#123;</div><div class="line">    DefaultEventExecutor worker = <span class="keyword">new</span> DefaultEventExecutor();</div><div class="line">    Promise&lt;String&gt; promise = fetchDataSchedule(worker);</div><div class="line">    </div><div class="line">    promise.addListener(future -&gt; &#123;</div><div class="line">        String result = promise.getNow();</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(result);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            promise.cause().printStackTrace();</div><div class="line">        &#125;</div><div class="line">        worker.shutdownGracefully();</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"do something else"</span>);</div><div class="line">    <span class="comment">// do something else</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过设置监听器接收消息通知，主线程不会等待，请求一旦返回，就会在回调中处理结果。（回调是在worker线程中执行的，因为DefaultPromise的构造函数传入的是work线程）发起请求后，由worker线程来执行请求，而主线程可以做别的事情，充分发挥了线程资源，提高了CPU的利用率。</p>
<p>异步是不是很棒棒呢？<br>异步回调的写法有个缺点，如果相互依赖的异步操作很多，相应的回调也会变得多，嵌套起来的画面太美，回调地狱（Callback Hell）可读性差且不利于维护。</p>
<p>解决回调地狱的办法也有很多，像RxJava、Android的Agera、JavaScript的Promise等等一系列的工具库。。。<br>这几个解决方式各不相同，但基本上都是用的同一个套路：用队列/栈保存回调，返回包装类，提供链式调用，最后表现出来的就是flatten后的回调。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同步-异步&quot;&gt;&lt;a href=&quot;#同步-异步&quot; class=&quot;headerlink&quot; title=&quot;同步 / 异步&quot;&gt;&lt;/a&gt;同步 / 异步&lt;/h1&gt;&lt;p&gt;Promise翻译过来大概是承诺的意思，在Netty中有什么用呢？&lt;/p&gt;
&lt;p&gt;为了更高效的IO（压榨多核
    
    </summary>
    
    
      <category term="Netty" scheme="https://huoguangjin.github.io/blog/tags/Netty/"/>
    
      <category term="Promise" scheme="https://huoguangjin.github.io/blog/tags/Promise/"/>
    
      <category term="同步/异步" scheme="https://huoguangjin.github.io/blog/tags/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Netty - FastThreadLocal</title>
    <link href="https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/"/>
    <id>https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/</id>
    <published>2017-04-21T12:48:09.000Z</published>
    <updated>2017-04-22T06:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例，常见用static修饰。通过ThreadLocal可以让实例做到在<code>线程作用域</code>内独立，不需要考虑线程安全问题，在多线程编程中有奇效，也算是优化手段的一种。其中一个很经典的应用就是Android中的Looper类。</p>
<p>下面是来自文档的一个示例，使用ThreadLocal来储存一个整型值来作为线程的id，由于有static修饰，所以可以在任意地方使用<code>ThreadId.get()</code>获取当前线程的id：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</div><div class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Thread local variable containing each thread's ID</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> threadId.get(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高性能网络框架Netty对ThreadLocal的实现进行了一番魔改，我们先来了解一下JDK中的ThreadLocal实现。</p>
<h1 id="JDK的ThreadLocal实现"><a href="#JDK的ThreadLocal实现" class="headerlink" title="JDK的ThreadLocal实现"></a>JDK的ThreadLocal实现</h1><p>ThreadLocal的实现，其实就是在Thread类里开了个挂。。<br>Thread类有一个成员变量threadLocals，类型是ThreadLocal.ThreadLocalMap，同一线程的所有线程独立实例就是集中储存在这个”Map”当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过虽然ThreadLocalMap名字中有”Map”，但是却没有实现Map接口，不过它实现方式和HashMap很相似，内部也有一个数组<code>Entry[] tab</code>，Entry类的声明很简单，就是一个储存key-value对的弱引用，key是ThreadLocal，而value就是我们要储存的线程独立实例，ThreadLocalMap看起来就像是一个<code>Map&lt;ThreadLocal, Object&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以ThreadLocal的set方法入手分析，set方法分为2步：</p>
<ol>
<li>获取从Thread中获取ThreadLocalMap</li>
<li>操作ThreadLocalMap设值</li>
</ol>
<p>这里的ThreadLocalMap使用了懒加载的策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到ThreadLocalMap后调用它的set方法设值，set方法逻辑很简单：首先由key的哈希值（ThreadLocal初始化时由nextHashCode()赋值）算出数组下标，然后将value设置到对应的Entry上，如果你了解过HashMap的源码，那么应该对这套路很熟悉，只不过有一点不同，那就是解决哈希冲突的策略。</p>
<p>按照惯例，哈希表都是有可能发生冲突的，如果发生冲突会清除无效的Entry（弱引用 e != null &amp;&amp; e.get() == null），必要时还需要扩容和重哈希，具体实现在replaceStaleEntry()、cleanSomeSlots()、rehash()等方法中，这里不展开说了(有bu兴pa趣si的同学可以了解一下，注释里有提示<code>Knuth, Section 6.4</code>)，我们暂时只要知道这个冲突解决起来很累。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> Entry[] table;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">       Entry[] tab = table;</div><div class="line">       <span class="keyword">int</span> len = tab.length;</div><div class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">            e != <span class="keyword">null</span>;</div><div class="line">            e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">           ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">           <span class="comment">// 如果是在第一轮循环中则命中,否则就是发生了冲突</span></div><div class="line">           <span class="keyword">if</span> (k == key) &#123;</div><div class="line">               e.value = value;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 空的或失效(stale)的Entry</span></div><div class="line">           <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">               replaceStaleEntry(key, value, i);</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 第一次设值</span></div><div class="line">       tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">       <span class="keyword">int</span> sz = ++size;</div><div class="line">       <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">           rehash();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h1><p>Netty为了高性能也是费尽了心思，专门造了个FastThreadLocal轮子来顶替ThreadLocal。</p>
<h2 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h2><p>和JDK的Thread很类似，FastThreadLocaThread继承自Thread，用一个成员变量来储存线程独立的实例，FastThreadLocalThread.InternalThreadLocalMap的作用相当于ThreadLocal.ThreadLocalMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和JDK相似，向FastThreadLocal设值需要两步：</p>
<ol>
<li>获取从FastThreadLocalThread中获取InternalThreadLocalMap</li>
<li>操作InternalThreadLocalMap设值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// io.netty.util.concurrent.FastThreadLocal.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">        set(InternalThreadLocalMap.get(), value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="InternalThreadLocalMap降级策略"><a href="#InternalThreadLocalMap降级策略" class="headerlink" title="InternalThreadLocalMap降级策略"></a>InternalThreadLocalMap降级策略</h2><p>如果当前线程为FastThreadLocalThread则调用它的threadLocalMap()从中获取InternalThreadLocalMap，否则使用UnpaddedInternalThreadLocalMap的<code>slowThreadLocalMap</code>获取普通的<code>ThreadLocal&lt;InternalThreadLocalMap&gt;</code>，再从中获取InternalThreadLocalMap。<br>同样地，InternalThreadLocalMap使用了懒加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// InternalThreadLocalMap.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">   Thread thread = Thread.currentThread();</div><div class="line">   <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</div><div class="line">       <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> slowGet();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</div><div class="line">   InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</div><div class="line">   <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</div><div class="line">       thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> threadLocalMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</div><div class="line">   ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</div><div class="line">   InternalThreadLocalMap ret = slowThreadLocalMap.get();</div><div class="line">   <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</div><div class="line">       ret = <span class="keyword">new</span> InternalThreadLocalMap();</div><div class="line">       slowThreadLocalMap.set(ret);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="获取FastThreadLocal"><a href="#获取FastThreadLocal" class="headerlink" title="获取FastThreadLocal"></a>获取FastThreadLocal</h2><p>InternalThreadLocalMap继承自UnpaddedInternalThreadLocalMap，真正储存的地方是在UnpaddedInternalThreadLocalMap的indexedVariables中，类型为Object[]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></div><div class="line">    Object[] indexedVariables;</div><div class="line">    </div><div class="line">    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;</div><div class="line">        <span class="keyword">this</span>.indexedVariables = indexedVariables;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在FastThreadLocal的构造函数中，由InternalThreadLocalMap.nextVariableIndex()方法分配一个下标index，index的作用相当于一个id，后续读写都由这个index从InternalThreadLocalMap的indexVariables中查找线程独立对象。</p>
<p>InternalThreadLocalMap.nextVariableIndex()是通过调用UnpaddedInternalThreadLocalMap的nextIndex.getAndIncrement()方法获取的下标的，nextIndex是原子类AtomicInteger，保证生成的index是唯一的。</p>
<p>与JDK的实现相比，Netty的实现不会发生冲突，直接使用数组索引，效率更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">            nextIndex.decrementAndGet();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">indexedVariable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        Object[] lookup = indexedVariables;</div><div class="line">        <span class="keyword">return</span> index &lt; lookup.length? lookup[index] : UNSET;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</div><div class="line">        Object[] lookup = indexedVariables;</div><div class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</div><div class="line">            Object oldValue = lookup[index];</div><div class="line">            lookup[index] = value;</div><div class="line">            <span class="keyword">return</span> oldValue == UNSET;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            expandIndexedVariableTableAndSet(index, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">        index = InternalThreadLocalMap.nextVariableIndex();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> get(InternalThreadLocalMap.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">            set(InternalThreadLocalMap.get(), value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">            <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</div><div class="line">                addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            remove(threadLocalMap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从nextVariableIndex()方法可以看出nextIndex只递增不会减少，溢出（index &lt; 0）的话就会抛出IllegalStateException异常，毕竟是要用这个下标从数组中取对象的，不能小于0这很合理。</p>
<p><strong>但是这里要注意：</strong>如果FastThreadLocal太多，index会越来越大，储存对象的indexedVariables数组为了满足需求会不断扩容，即使某些FastThreadLocal不会再使用。线程是不常回收的资源，线程FastThreadLocalThread持有的InternalThreadLocalMap也不会回收，这有可能会导致indexedVariables成为一个大数组，就算其中有大量空余的空间也无法再利用，也就是说这是个<strong>内存泄露</strong>点。反观JDK的实现，Entry是弱引用，经过清理操作后的空间可以被复用。</p>
<p>当然，如果数量需求不大，事实上不会有问题。在Netty中，FastThreadLocal的一个典型应用就是io.netty.util.Recycler类，它的作用就是个对象池，复用对象。<strong>对于多次使用的、创建开销大、线程无关的可复用对象都可以考虑使用ThreadLocal来优化</strong>。</p>
<p>事实上，Netty的FastThreadLocal分析到这里就结束了，不过因为内容相关，顺带加2个彩蛋：</p>
<h1 id="Android-SDK的ThreadLocal实现"><a href="#Android-SDK的ThreadLocal实现" class="headerlink" title="Android SDK的ThreadLocal实现"></a>Android SDK的ThreadLocal实现</h1><p>Android(SDK23)中的ThreadLocal实现和JDK中的实现有些区别。ThreadLocal内部有弱引用reference，弱引用指向自身，哈希值取值也不一样，set方法倒是没什么区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class="line">            = <span class="keyword">new</span> WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger hashCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash = hashCounter.getAndAdd(<span class="number">0x61c88647</span> * <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line">        Values values = values(currentThread);</div><div class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">            values = initializeValues(currentThread);</div><div class="line">        &#125;</div><div class="line">        values.put(<span class="keyword">this</span>, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal.Values和JDK中的ThreadLocal.ThreadLocalMap的作用很相似，也是用数组作为元素的容器，但是没有Entry类来存key-value对，而是直接用了<code>Object[] table</code>来代替，其中偶数索引的元素上存key，紧挨着的下一个元素存vlaue。</p>
<p>每一次put都会先调用cleanUp()方法，cleanUp方法先判断需不需要扩容，如果扩容会自然地把失效的元素<strong>清除</strong>掉，如果不需要扩容，则按<code>log2(table.length)</code>的间距检查并<strong>标记</strong>失效的元素，之后再来做真正的插入操作。所谓的标记，就是把key位置上的元素用<code>TOMBSTONE</code>作占位，然后把value位置上的元素置为null，ThreadLocal调用remove方法删除实例的逻辑也是用的这种标记。</p>
<p>cleanUp()方法后，put方法剩余的部分很容易看懂，其中解决冲突的策略是：向后索引，插入到第一个空的或者<code>TOMBSTONE</code>的点上，从put方法可以看出Android中ThreadLocal解决冲突的策略相当的简单粗暴。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object TOMBSTONE = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object[] table;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">        cleanUp();</div><div class="line"></div><div class="line">        <span class="comment">// Keep track of first tombstone. That's where we want to go back</span></div><div class="line">        <span class="comment">// and add an entry if necessary.</span></div><div class="line">        <span class="keyword">int</span> firstTombstone = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">            Object k = table[index];</div><div class="line"></div><div class="line">            <span class="comment">// 如果是在第一轮循环中,则命中,否则就是发生了冲突</span></div><div class="line">            <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">                <span class="comment">// Replace existing entry.</span></div><div class="line">                table[index + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 空的或失效的ThreadLocal</span></div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">                    <span class="comment">// Fill in null slot.</span></div><div class="line">                    table[index] = key.reference;</div><div class="line">                    table[index + <span class="number">1</span>] = value;</div><div class="line">                    size++;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">                table[firstTombstone] = key.reference;</div><div class="line">                table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">                tombstones--;</div><div class="line">                size++;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Remember first tombstone.</span></div><div class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">                firstTombstone = index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (rehash()) &#123;</div><div class="line">            <span class="comment">// If we rehashed, we needn't clean up (clean up happens as</span></div><div class="line">            <span class="comment">// a side effect).</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// No live entries == nothing to clean.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Clean log(table.length) entries picking up where we left off</span></div><div class="line">        <span class="comment">// last time.</span></div><div class="line">        <span class="keyword">int</span> index = clean;</div><div class="line">        Object[] table = <span class="keyword">this</span>.table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = table.length; counter &gt; <span class="number">0</span>; counter &gt;&gt;= <span class="number">1</span>,</div><div class="line">                index = next(index)) &#123;</div><div class="line">            Object k = table[index];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (k == TOMBSTONE || k == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// on to next entry</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// The table can only contain null, tombstones and references.</span></div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class="line">                    = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class="line">            <span class="keyword">if</span> (reference.get() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// This thread local was reclaimed by the garbage collector.</span></div><div class="line">                table[index] = TOMBSTONE;</div><div class="line">                table[index + <span class="number">1</span>] = <span class="keyword">null</span>;</div><div class="line">                tombstones++;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Point cursor to next index.</span></div><div class="line">        clean = index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h1><p>InheritableThreadLocal顾名思义就是有继承能力的ThreadLocal，子线程可以”继承”父线程内原有的InheritableThreadLocal变量。用起来很神奇，其实实现上也是Thread类里开了挂。。。</p>
<p>InheritableThreadLocal中的内容很少，只是复写了ThreadLocal的3个方法：<code>childValue</code>、<code>getMap</code>、<code>createMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123; <span class="keyword">return</span> parentValue; &#125;</div><div class="line"></div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123; <span class="keyword">return</span> t.inheritableThreadLocals; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal中原方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadLocal</span></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123; <span class="keyword">return</span> t.threadLocals; &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">   t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比两者可以看到，ThreadLocal的ThreadLocalMap是从thread的<code>threadLocals</code>变量中获取的，而InheritableThreadLocal的ThreadLocalMap则是从thread的<code>inheritableThreadLocals</code>变量获取的。</p>
<p>来看看Thread中开的挂：Thread的构造函数会调用init方法，然后将当前线程的inheritableThreadLocals复制了一份保存下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread</span></div><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">* by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* InheritableThreadLocal values pertaining to this thread. This map is</div><div class="line">* maintained by the InheritableThreadLocal class.</div><div class="line">*/</div><div class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    Thread parent = currentThread();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal.createInheritedMap的实现如下，从中可以看到，所谓的”继承”，其实只是一次浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadLocalMap</span></div><div class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    Entry[] parentTable = parentMap.table;</div><div class="line">    <span class="keyword">int</span> len = parentTable.length;</div><div class="line">    setThreshold(len);</div><div class="line">    table = <span class="keyword">new</span> Entry[len];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        Entry e = parentTable[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</div><div class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">                Object value = key.childValue(e.value);</div><div class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</div><div class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                table[h] = c;</div><div class="line">                size++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例
    
    </summary>
    
    
      <category term="Netty" scheme="https://huoguangjin.github.io/blog/tags/Netty/"/>
    
      <category term="ThreadLocal" scheme="https://huoguangjin.github.io/blog/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
