<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuoGuangjin</title>
  <subtitle>不安分的Android Dev</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://huoguangjin.github.io/blog/"/>
  <updated>2017-04-21T15:50:27.000Z</updated>
  <id>https://huoguangjin.github.io/blog/</id>
  
  <author>
    <name>HuoGuangjin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty - FastThreadLocal</title>
    <link href="https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/"/>
    <id>https://huoguangjin.github.io/blog/2017/04/Netty-FastThreadLocal/</id>
    <published>2017-04-21T12:48:09.000Z</published>
    <updated>2017-04-21T15:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例，常见用static修饰。通过ThreadLocal可以让实例做到在线程作用域内独立，不需要考虑线程安全问题，在多线程编程中有奇效，也算是优化手段的一种。其中一个很经典的应用就是Android中的Looper类。</p>
<p>下面是来自文档的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</div><div class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Thread local variable containing each thread's ID</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Returns the current thread's unique ID, assigning it if necessary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> threadId.get(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高性能网络框架Netty对ThreadLocal进行了一番魔改，我们先来了解一下JDK中的ThreadLocal实现。</p>
<h1 id="JDK的ThreadLocal实现"><a href="#JDK的ThreadLocal实现" class="headerlink" title="JDK的ThreadLocal实现"></a>JDK的ThreadLocal实现</h1><p>ThreadLocal的实现，其实就是在Thread类里开了个挂。。<br>Thread类有一个成员变量threadLocals类型，是ThreadLocal.ThreadLocalMap，同一线程所有的线程独立实例就是集中储存在这个”Map”当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过虽然ThreadLocalMap名字中有”Map”，但是却没有实现Map接口，不过它实现方式和HashMap很相似，内部也有一个数组Entry[] tab，Entry类的声明很简单，就是一个储存key-value对的弱引用，key是ThreadLocal，而value就是我们要储存的线程独立实例，ThreadLocalMap看起来就像是一个<code>Map&lt;ThreadLocal, Object&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以ThreadLocal的set方法入手分析，set方法分为2步：</p>
<ol>
<li>获取从Thread中获取ThreadLocalMap</li>
<li>操作ThreadLocalMap设值</li>
</ol>
<p>这里的ThreadLocalMap使用了懒加载的策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap的set方法逻辑很简单：首先由key的哈希值（ThreadLocal初始化时由nextHashCode()赋值）算出数组下标，然后将value设置到对应的Entry上，如果你了解过HashMap的源码，那么应该对这套路很熟悉，只不过有一点不同，那就是解决哈希冲突的策略。</p>
<p>按照惯例，哈希表都是有可能发生冲突的，如果发生冲突会清除无效的Entry（弱引用 e != null &amp;&amp; e.get() == null），必要时还需要扩容和重哈希，具体实现在replaceStaleEntry()、cleanSomeSlots()、rehash()等方法中，这里不展开说了(有bu兴pa趣si的同学可以了解一下，注释里有提示<code>Knuth, Section 6.4</code>)，我们暂时只要知道这个冲突解决起来很累。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> Entry[] table;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">       Entry[] tab = table;</div><div class="line">       <span class="keyword">int</span> len = tab.length;</div><div class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">            e != <span class="keyword">null</span>;</div><div class="line">            e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">           ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">           <span class="comment">// 如果是在第一轮循环中,则命中否则就是发生了冲突</span></div><div class="line">           <span class="keyword">if</span> (k == key) &#123;</div><div class="line">               e.value = value;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 空的或失效(stale)的Entry</span></div><div class="line">           <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">               replaceStaleEntry(key, value, i);</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 第一次设值</span></div><div class="line">       tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">       <span class="keyword">int</span> sz = ++size;</div><div class="line">       <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">           rehash();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h1><p>Netty为了高性能也是费尽了心思，专门造了个FastThreadLocal轮子来顶替ThreadLocal。</p>
<h2 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h2><p>和JDK的Thread很类似，FastThreadLocaThread继承自Thread，用一个成员变量来储存线程独立的实例，FastThreadLocalThread.InternalThreadLocalMap的作用相当于ThreadLocal.ThreadLocalMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和JDK相似，向FastThreadLocal设值需要两步：</p>
<ol>
<li>获取从FastThreadLocalThread中获取InternalThreadLocalMap</li>
<li>操作InternalThreadLocalMap设值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// io.netty.util.concurrent.FastThreadLocal.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> get(InternalThreadLocalMap.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="InternalThreadLocalMap降级策略"><a href="#InternalThreadLocalMap降级策略" class="headerlink" title="InternalThreadLocalMap降级策略"></a>InternalThreadLocalMap降级策略</h2><p>如果当前线程为FastThreadLocalThread则调用它的threadLocalMap()从中获取InternalThreadLocalMap，否则使用UnpaddedInternalThreadLocalMap的<code>slowThreadLocalMap</code>获取普通的<code>ThreadLocal&lt;InternalThreadLocalMap&gt;</code>，再从中获取InternalThreadLocalMap。<br>同样地，InternalThreadLocalMap使用了懒加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// InternalThreadLocalMap.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">   Thread thread = Thread.currentThread();</div><div class="line">   <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</div><div class="line">       <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> slowGet();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</div><div class="line">   InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</div><div class="line">   <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</div><div class="line">       thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> threadLocalMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</div><div class="line">   ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</div><div class="line">   InternalThreadLocalMap ret = slowThreadLocalMap.get();</div><div class="line">   <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</div><div class="line">       ret = <span class="keyword">new</span> InternalThreadLocalMap();</div><div class="line">       slowThreadLocalMap.set(ret);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="获取FastThreadLocal"><a href="#获取FastThreadLocal" class="headerlink" title="获取FastThreadLocal"></a>获取FastThreadLocal</h2><p>InternalThreadLocalMap继承自UnpaddedInternalThreadLocalMap，真正储存的地方是在UnpaddedInternalThreadLocalMap的indexedVariables中，类型为Object[]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></div><div class="line">    Object[] indexedVariables;</div><div class="line">    </div><div class="line">    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;</div><div class="line">        <span class="keyword">this</span>.indexedVariables = indexedVariables;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在FastThreadLocal的构造函数中，由InternalThreadLocalMap.nextVariableIndex()方法分配一个下标index，index的作用相当于一个id，后续读写都由这个index从InternalThreadLocalMap的indexVariables中查找线程独立对象。</p>
<p>InternalThreadLocalMap.nextVariableIndex()是通过调用UnpaddedInternalThreadLocalMap的nextIndex.getAndIncrement()方法获取的下标的，nextIndex是原子类AtomicInteger，保证生成的index是唯一的。<br>与JDK的实现相比，Netty的实现不会发生冲突，直接使用数组下标做索引，相比之下效率更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">            nextIndex.decrementAndGet();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">indexedVariable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        Object[] lookup = indexedVariables;</div><div class="line">        <span class="keyword">return</span> index &lt; lookup.length? lookup[index] : UNSET;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</div><div class="line">        Object[] lookup = indexedVariables;</div><div class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</div><div class="line">            Object oldValue = lookup[index];</div><div class="line">            lookup[index] = value;</div><div class="line">            <span class="keyword">return</span> oldValue == UNSET;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            expandIndexedVariableTableAndSet(index, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">        index = InternalThreadLocalMap.nextVariableIndex();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> get(InternalThreadLocalMap.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">            set(InternalThreadLocalMap.get(), value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">            <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</div><div class="line">                addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            remove(threadLocalMap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从nextVariableIndex()方法可以看出nextIndex只递增不会减少，获取下标溢出（index &lt; 0）的话就会抛出IllegalStateException异常，毕竟是要用这个下标从数组中取对象的，不能小于0这很合理。</p>
<p><strong>但是这里要注意：</strong>如果FastThreadLocal太多，index会越来越大，储存对象的indexedVariables数组为了满足需求会不断扩容，即使某些FastThreadLocal不会再使用。线程是不常回收的资源，线程FastThreadLocalThread持有的InternalThreadLocalMap也不会回收，这有可能会导致indexedVariables成为一个大数组，就算其中有大量空余的空间也无法再利用，也就是说会发生<strong>内存泄露</strong>。反观JDK的实现，Entry是弱引用，经过清理操作后的空间可以被复用。</p>
<p>当然，如果数量需求不大，事实上不会有问题。在Netty中，FastThreadLocal的一个典型应用就是io.netty.util.Recycler类，它的作用就是个对象池，复用对象。<strong>对于多次使用的、创建开销大、线程无关的可复用对象都可以考虑使用ThreadLocal来优化</strong>。</p>
<p>事实上，Netty的FastThreadLocal分析到这里就结束了，不过因为内容相关，顺带加2个彩蛋：</p>
<h1 id="Android-SDK的ThreadLocal实现"><a href="#Android-SDK的ThreadLocal实现" class="headerlink" title="Android SDK的ThreadLocal实现"></a>Android SDK的ThreadLocal实现</h1><p>Android(SDK23)中的ThreadLocal实现和JDK中的实现有些区别。ThreadLocal内部有弱引用reference，弱引用指向自身，哈希值取值也不一样，set方法倒是没什么区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reference&lt;ThreadLocal&lt;T&gt;&gt; reference</div><div class="line">            = <span class="keyword">new</span> WeakReference&lt;ThreadLocal&lt;T&gt;&gt;(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger hashCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash = hashCounter.getAndAdd(<span class="number">0x61c88647</span> * <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line">        Values values = values(currentThread);</div><div class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">            values = initializeValues(currentThread);</div><div class="line">        &#125;</div><div class="line">        values.put(<span class="keyword">this</span>, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal.Values和JDK中的ThreadLocal.ThreadLocalMap的作用很相似，也是用数组作为元素的容器，但是没有Entry类来存key-value对，而是直接用了Object[] table来代替，其中偶数索引的元素上存key，紧挨着的下一个元素存vlaue。</p>
<p>每一次put都会先调用cleanUp()方法，cleanUp方法先判断需不需要扩容，如果扩容会自然地把失效的元素<strong>清除</strong>掉，如果不需要扩容，则按log2(table.length)的间距检查并<strong>标记</strong>失效的元素，之后再来做真正的插入操作。所谓的标记，就是把key位置上的元素用TOMBSTONE作占位，然后把value位置上的元素置为null，ThreadLocal调用remove方法删除ThreadLocal的逻辑也是如此。</p>
<p>cleanUp()方法后，put方法剩余的部分很容易看懂，其中解决冲突的策略是：向后索引，插入到第一个空的或者TOMBSTONE的点上，从put方法可以看出Android中ThreadLocal解决冲突的策略相当的简单粗暴。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object TOMBSTONE = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object[] table;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">        cleanUp();</div><div class="line"></div><div class="line">        <span class="comment">// Keep track of first tombstone. That's where we want to go back</span></div><div class="line">        <span class="comment">// and add an entry if necessary.</span></div><div class="line">        <span class="keyword">int</span> firstTombstone = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">            Object k = table[index];</div><div class="line"></div><div class="line">            <span class="comment">// 如果是在第一轮循环中,则命中,否则就是发生了冲突</span></div><div class="line">            <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">                <span class="comment">// Replace existing entry.</span></div><div class="line">                table[index + <span class="number">1</span>] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 空的或失效的ThreadLocal</span></div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">                    <span class="comment">// Fill in null slot.</span></div><div class="line">                    table[index] = key.reference;</div><div class="line">                    table[index + <span class="number">1</span>] = value;</div><div class="line">                    size++;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">                table[firstTombstone] = key.reference;</div><div class="line">                table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">                tombstones--;</div><div class="line">                size++;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Remember first tombstone.</span></div><div class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">                firstTombstone = index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (rehash()) &#123;</div><div class="line">            <span class="comment">// If we rehashed, we needn't clean up (clean up happens as</span></div><div class="line">            <span class="comment">// a side effect).</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// No live entries == nothing to clean.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Clean log(table.length) entries picking up where we left off</span></div><div class="line">        <span class="comment">// last time.</span></div><div class="line">        <span class="keyword">int</span> index = clean;</div><div class="line">        Object[] table = <span class="keyword">this</span>.table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = table.length; counter &gt; <span class="number">0</span>; counter &gt;&gt;= <span class="number">1</span>,</div><div class="line">                index = next(index)) &#123;</div><div class="line">            Object k = table[index];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (k == TOMBSTONE || k == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">// on to next entry</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// The table can only contain null, tombstones and references.</span></div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Reference&lt;ThreadLocal&lt;?&gt;&gt; reference</div><div class="line">                    = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k;</div><div class="line">            <span class="keyword">if</span> (reference.get() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// This thread local was reclaimed by the garbage collector.</span></div><div class="line">                table[index] = TOMBSTONE;</div><div class="line">                table[index + <span class="number">1</span>] = <span class="keyword">null</span>;</div><div class="line">                tombstones++;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Point cursor to next index.</span></div><div class="line">        clean = index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h1><p>InheritableThreadLocal顾名思义就是有继承能力的ThreadLocal，子线程可以”继承”父线程内原有的ThreadLocal变量。用起来很神奇，其实实现上也是Thread类里开了挂。。。</p>
<p>InheritableThreadLocal中的内容很少，只是复写了ThreadLocal的3个方法：<code>childValue</code>、<code>getMap</code>、<code>createMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123; <span class="keyword">return</span> parentValue; &#125;</div><div class="line"></div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal中原方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadLocal</span></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">   t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比两者可以看到，ThreadLocal的ThreadLocalMap是从thread的threadLocals变量中获取的，而InheritableThreadLocal的ThreadLocalMap则是从thread的inheritableThreadLocals变量获取的。</p>
<p>来看看Thread中开的挂：Thread的构造函数会调用init方法，然后将当前线程的inheritableThreadLocals复制了一份保存下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread</span></div><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">* by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* InheritableThreadLocal values pertaining to this thread. This map is</div><div class="line">* maintained by the InheritableThreadLocal class.</div><div class="line">*/</div><div class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    Thread parent = currentThread();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal.createInheritedMap的实现如下，从中可以看到，所谓的”继承”，其实只是一次浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ThreadLocalMap</span></div><div class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    Entry[] parentTable = parentMap.table;</div><div class="line">    <span class="keyword">int</span> len = parentTable.length;</div><div class="line">    setThreshold(len);</div><div class="line">    table = <span class="keyword">new</span> Entry[len];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        Entry e = parentTable[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</div><div class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">                Object value = key.childValue(e.value);</div><div class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</div><div class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                table[h] = c;</div><div class="line">                size++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal是一个泛型参数的类，主要用于储存线程独立的实例
    
    </summary>
    
    
      <category term="Netty" scheme="https://huoguangjin.github.io/blog/tags/Netty/"/>
    
      <category term="ThreadLocal" scheme="https://huoguangjin.github.io/blog/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
